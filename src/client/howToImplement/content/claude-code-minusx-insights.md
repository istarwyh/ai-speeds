# CC 为什么这么好：MinusX 解析

## 核心洞察

Claude Code 之所以让人愉悦，关键在于它对 LLM 能力的深刻理解：**知道模型擅长什么，不擅长什么**。其提示词和工具设计巧妙地弥补了模型的愚蠢，同时让它在擅长的领域发光发热。

## 设计哲学：Keep Things Simple, Dummy

### 🎯 核心原则
- **单一主循环**：避免复杂的LangChain图节点混合架构
- **小模型优先**：Haiku 处理 50%+ 的重要调用
- **架构简单性**：在每个分叉路口都选择最简单方案

## 控制循环设计

### 1.1 单一主循环
```
调试性 >> 复杂的LangChain图节点混合架构
```

Claude Code 只有一个主线程，使用简单的提示词定期总结 git 历史、合并消息历史。处理复杂任务时，通过克隆自身作为子代理，但**最多只有一个分支**。

**关键设计**：
- 单一主循环处理简单任务
- 复杂任务创建子代理（无递归）
- Todo 列表确保最终目标不丢失

### 1.2 小模型大用途
- **Haiku 使用场景**：
  - 读取大文件
  - 解析网页
  - 处理 git 历史
  - 对话总结
  - 实时标签生成

- **成本优势**：小模型比标准模型便宜 70-80%

## 提示工程精髓

### 2.1 claude.md 模式
```markdown
# 项目偏好配置
- 跳过 node_modules/ 目录
- 优先使用 TypeScript
- 函数不超过 15 行
- 使用绝对路径避免 cd
```

**效果**：有/无 claude.md 的性能差异是**天壤之别**

### 2.2 结构化提示
- **XML 标签**：`<system-reminder>`, `<good-example>`, `<bad-example>`
- **Markdown 分区**：Tone, Style, Proactiveness
- **示例丰富**：每个决策点都有具体案例

### 2.3 重要提示标记
```
IMPORTANT: DO NOT ADD ***ANY*** COMMENTS unless asked
VERY IMPORTANT: MUST avoid using search commands...
```

> "THIS IS IMPORTANT" 仍是当前 SOTA 的引导技术

## 工具设计原则

### 3.1 LLM 搜索 >> RAG 搜索

**Claude Code 的做法**：
- 复杂正则表达式直接搜索代码
- 理解代码结构后用 rg/jq/find
- 避免 RAG 的隐藏失败模式

**优势**：
- 无相似度函数选择问题
- 无分块策略困扰
- 可 RL 学习，减少系统复杂度

### 3.2 工具层次化设计

| 级别 | 工具示例 | 使用频率 | 确定性 |
|------|----------|----------|--------|
| 低级 | Bash, Read, Write | 高 | 低 |
| 中级 | Edit, Grep, Glob | 高 | 中 |
| 高级 | Task, WebFetch | 中 | 高 |

**设计原则**：
- 高频工具单独封装
- 特殊场景用 Bash
- 确定性操作用高级工具

### 3.3 Todo 列表管理

**Claude Code 的巧妙之处**：
- 模型自己维护 todo 列表
- 防止上下文腐烂
- 灵活调整任务路径
- 利用模型思考能力动态增删

## 可操控性技巧

### 4.1 语调控制
```
- 避免不必要的开场白
- 不主动解释代码（除非要求）
- 重要信息简洁表达
```

### 4.2 算法化决策流程
**不要**：大杂烩的 Do/Don't 列表
**应该**：清晰的决策流程图

示例：
```
如果任务简单 → 主循环处理
如果任务复杂 → 创建子代理
始终 → 维护 todo 列表
```

## 实用建议清单

### ✅ 立即应用
1. **项目配置**：在 claude.md 中明确项目偏好
2. **路径习惯**：优先使用绝对路径
3. **任务管理**：主动使用 TodoWrite 工具
4. **成本控制**：充分利用小模型处理大文件
5. **架构选择**：避免多代理系统的复杂性

### 🎯 高级技巧
1. **提示结构化**：用 XML 标签和 Markdown 分区
2. **重要标记**：关键约束用 "IMPORTANT" 强调
3. **示例丰富**：每个决策点提供具体案例
4. **算法思维**：将复杂决策流程化
5. **调试优先**：保持架构简单可调试

## 为什么关注 BigLab 的提示？

> "反向工程后训练/RLHF 数据分布的最好方式就是看他们在自己的应用中怎么做"

Claude Code 的设计非常固执己见，但正是这种固执让它如此优秀。学习这些模式，形成你自己的设计哲学。

## 结论

**核心启示**：代理可以既简单又强大。Claude Code 证明了极端的脚手架框架弊大于利。

---

**参考文献**：
- [MinusX 博客原文](https://minusx.ai/blog/decoding-claude-code/)